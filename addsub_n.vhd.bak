-- addsub_n.vhd
library ieee;
use ieee.std_logic_1164.all;

entity addsub_n is
  generic(N : integer := 4);
  port(
    A       : in  std_logic_vector(N-1 downto 0);
    B       : in  std_logic_vector(N-1 downto 0);
    AddSub  : in  std_logic;  -- 0: add, 1: subtract (A - B)
    S       : out std_logic_vector(N-1 downto 0);
    Cout    : out std_logic;  -- 进位(加)/借位(减) 输出（原始 RCA 的 cout）
    V_ovf   : out std_logic   -- 2's complement 溢出指示（可选，但建议给）
  );
end entity;

architecture structural of addsub_n is
  component rca_n
    generic(N : integer := 4);
    port(a, b: in std_logic_vector(N-1 downto 0);
         cin : in std_logic;
         s   : out std_logic_vector(N-1 downto 0);
         cout: out std_logic);
  end component;

  signal Bx : std_logic_vector(N-1 downto 0);
  signal c_out  : std_logic;
  signal c_mid  : std_logic_vector(N downto 0);
begin
  -- 位级异或实现条件取反：AddSub=1 时对 B 取反
  gen_xor: for i in 0 to N-1 generate
    Bx(i) <= B(i) xor AddSub;
  end generate;

  -- 串行进位加法器：Cin = AddSub，实现 A + B 或 A + (~B) + 1
  U_RCA: rca_n
    generic map(N => N)
    port map(
      a    => A,
      b    => Bx,
      cin  => AddSub,
      s    => S,
      cout => c_out
    );
  Cout <= c_out;

  -- 2's complement 溢出检测：MSB 的“进位入” XOR “进位出”
  -- 这里复用 rca 级联思想：可简化为 (A(N-1) and Bx(N-1) and not S(N-1)) or ...
  -- 但更通用的是：V = carry_into_MSB xor carry_out_of_MSB
  -- 由于 rca_n 内部没直接导出“进位入 MSB”，这里用经典符号法近似实现：
  V_ovf <= (A(N-1) and Bx(N-1) and (not S(N-1))) or
           ((not A(N-1)) and (not Bx(N-1)) and S(N-1));
end architecture;
